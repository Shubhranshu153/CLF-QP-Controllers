function [h,dH] = dynamics_constraints(z, N, nx)
%DYNAMICS_CONSTRAINTS(z) compiles the dynamics constraints generated by
%dynamics_constraint_with_derivative.
%
%   @param z: decision variable (column) vector containing the x_i and u_i
%   @param N: number of sample points; scalar
%   @param nx: dimension of state vector, x; scalar

%   @output h: compiled h_i from dynamics_constraint_with_derivative;
%   (N-1)*nx by 1 vector
%   @output dH_i: compiled dH_i from dynamics_constraint_with_derivative;
%   (N-1)*nx by nz matrix

    h = zeros((N-1)*nx, 1);
    dH = zeros((N-1)*nx, numel(z));

    for i=1:(N-1)
        [x_i_inds,dt_i_inds] = sample_indices(i, nx);
        [x_ip1_inds,~] = sample_indices(i + 1, nx);

        % TODO: call dynamics_constraint_with_derivative ith sample
        [h_i, dH_i] = dynamics_constraint_with_derivative(z(x_i_inds), ...
            z(dt_i_inds), z(x_ip1_inds));

        % TODO fit h_i and dH_i into h and dH, respectively.
        h((1:nx) + nx * (i-1)) = h_i;
        dH((1:nx) + nx * (i-1), [x_i_inds dt_i_inds x_ip1_inds]) = dH_i;

    end

end

function [h_i,dH_i] = dynamics_constraint_with_derivative(x_i, dt_i, x_ip1)
%DYNAMICS_CONSTRAINT_WITH_DERIVATIVE(x_i, dt_i, x_ip1) returns
%and computes the gradient of the vector constraint asssociated with
%evaluate_dynamics_constraint(x_i, dt_i, x_ip1).
%
%   @param x_i: the state at the start of the interval; nx by 1 vector
%   @param dt_i: the duratino of the interval; scalar
%   @param x_ip1: the state at the end of the interval; nx by 1 vector
%
%   @output h_i: constraint value from dynamics_constraint; nx by 1 vector
%   @output dH_i: jacobian of h_i w.r.t. [x_i; dt_i; x_ip1]; nx by
%   (2nx + 1) matrix

    h_i = evaluate_dynamics_constraint(x_i, dt_i, x_ip1);
    if nargout > 1
      % use numerical derivatives to compute dH
      % dH = [dh/dx0 dh/du0 dh/dx1 dh/du1]
      % where the partial derivatives are written (dh/dx0)_ij = dh_i/dx0_j
      delta = 1e-8;
      dH_i = zeros(numel(x_i), 2*numel(x_i) + 1);
      for j=1:numel(x_i)
          dx = zeros(numel(x_i),1);
          dx(j) = delta;
          dHx_i_j = ...
              evaluate_dynamics_constraint(x_i + dx, dt_i, x_ip1) - h_i;
          dHx_ip1_j = ...
              evaluate_dynamics_constraint(x_i, dt_i, x_ip1 + dx) - h_i;
          dH_i(:,j) = dHx_i_j/delta;
          dH_i(:,j + numel(x_i) + 1) = dHx_ip1_j/delta;
      end

      ddt = delta;
      dHdt_i = evaluate_dynamics_constraint(x_i, dt_i + ddt, x_ip1) - h_i;
      dH_i(:,numel(x_i) + 1) = dHdt_i/delta;
      
    end
end


function h_i = evaluate_dynamics_constraint(x_i, dt_i, x_ip1)
%EVALUATE_DYNAMICS_CONSTRAINT(x_i, dt_i, x_ip1) computes the
%   vector contstraint h_i(x_i, dt_i, x_ip1) = 0
%
%   @param x_i: the state at the start of the interval; nx by 1 vector
%   @param dt_i: the duratino of the interval; scalar
%   @param x_ip1: the state at the end of the interval; nx by 1 vector
%
%   @output h_i: constraint value; nx by 1 vector
dt = dt_i;

f_i = f(x_i);
f_ip1 = f(x_ip1);

s_i_mid = 0.5 * (x_i + x_ip1) - (dt / 8) * (f_ip1 - f_i);

s_i_dot_mid = (1.5 / dt) * (x_ip1 - x_i) - 0.25 * (f_i + f_ip1);

h_i = s_i_dot_mid - f(s_i_mid);

end